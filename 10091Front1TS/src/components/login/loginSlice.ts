import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';
import {AppThunk, RootState} from '../../app/store';
import {post} from "../../utilities/api1";
import {LOGIN, LOGOUT} from "../../utilities/url1";
import {LoginRequestDto, RefreshRequestDto} from "../../dto/dto";

export interface AuthState {
    token: string;
    status: 'idle' | 'loading' | 'failed';
}

const initialState: AuthState = {
    token: '',
    status: 'idle',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const loginRequestPost = createAsyncThunk(
    'login/post',
    async (login: LoginRequestDto) => {
        const response = await post(LOGIN, login);
        if (response !== undefined) {
            setToken(response)
            console.log(response)
            localStorage.setItem("token", response.token)
            localStorage.setItem("expiresAt", response.expiresAt)
            localStorage.setItem("username", response.username)
            localStorage.setItem("refresh", response.refresh)
        }
        return response;
    }
);

export const logoutRequestPost = createAsyncThunk(
    'logout/post',
    async () => {

        let username = localStorage.getItem("username");
        let refresh = localStorage.getItem("refresh");
        if (username != null && refresh != null) {
            const logout: RefreshRequestDto = {
                username: username,
                refresh: refresh
            }
            const response = await post(LOGOUT, logout);
            if (response !== undefined) {
                localStorage.removeItem("token")
                localStorage.removeItem("expiresAt")
                localStorage.removeItem("username")
                localStorage.removeItem("refresh")
                return response;
            }
        }
    }
);


export const loginSlice = createSlice({
    name: 'counter',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setToken: (state, action: PayloadAction<string>) => {
            state.token += action.payload;
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(loginRequestPost.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(loginRequestPost.fulfilled, (state, action) => {
                state.status = 'idle';
                state.token += action.payload;
            });
    },
});

export const {setToken} = loginSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectToken = (state: RootState) => state.login.token;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const updateToken = (token: string): AppThunk => (
    dispatch,
    getState
) => {
    const currentToken = selectToken(getState());
    if (currentToken !== undefined) {
        dispatch(setToken(token));
    }
};

export default loginSlice.reducer;
